はい、承知いたしました。先のPython SIPプロキシのプログラムのREADME.mdを作成します。

-----

# Simple Python SIP Proxy (for Learning Purposes)

このプロジェクトは、NAT (Network Address Translation) 環境下やSIPプロキシを経由するSIP (Session Initiation Protocol) 通信の基本的なルーティングとSIPヘッダの処理を理解するための、非常にシンプルなPython製SIPプロキシです。

**重要:** このプログラムは学習目的で作成されており、実際のプロダクション環境での使用には適していません。実際のSIPプロキシは、はるかに複雑で堅牢な機能（トランザクション管理、ダイアログ管理、認証、登録、各種エラー処理、トランスポート層の多様なサポートなど）を必要とします。

## 概要

このSIPプロキシは、主に以下の機能を提供することで、SIPシグナリングのルーティングを模擬します。

  * **SIPメッセージのパースと再構築**: 受信したSIPメッセージのヘッダとボディを解析し、変更後に再構築します。
  * **Viaヘッダの処理**: リクエストのViaヘッダに`received`と`rport`パラメータを追加し、応答時にこれを参照して適切な宛先にメッセージを転送します。
  * **Record-Routeヘッダの挿入**: `INVITE`リクエストに対して`Record-Route`ヘッダを挿入し、確立されたダイアログ内の後続リクエスト（`ACK`, `BYE`など）がこのプロキシを経由するように強制します。
  * **Contactヘッダの書き換え**: NATの内側にいるユーザーエージェント (UA) からの`INVITE`リクエストや、その応答の`200 OK`に含まれる`Contact`ヘッダを、NAT越え後のグローバルIPアドレスに書き換える処理を模擬します。
  * **Request-URIおよびRouteヘッダに基づくルーティング**: 受信したSIPメッセージのRequest-URIやRouteヘッダを解析し、次の転送先（ネクストホップ）を決定します。
  * **UDPトランスポートのみサポート**: TCPやTLSはサポートしていません。

## プロキシが「IPヘッダやUDPヘッダの書き換え」を直接行わない理由

このプログラムは、SIPメッセージのパケットのIPヘッダやUDPヘッダを直接書き換えません。SIPプロキシは、アプリケーション層でSIPメッセージの**内容（特にViaヘッダ、Record-Routeヘッダ、Contactヘッダ、およびSDP内のIPアドレス）** を適切に変更します。

変更されたSIPメッセージは、標準のUDPソケットを通じてオペレーティングシステム (OS) に送信されます。OSのネットワークスタックが、そのSIPメッセージのバイト列をUDPデータグラムとしてカプセル化し、**自動的に適切なIPヘッダとUDPヘッダを生成して付加し、物理ネットワークに送信します。**

したがって、SIPプロキシは、SIPメッセージのシグナリング情報（つまり、会話の内容）を操作することで、間接的にネットワーク層でのパケットのルーティングや到達性を制御します。低レイヤーのヘッダ操作はOSに委ねられます。

## 想定されるシナリオ

  * **UA1 (NAT内)** → **SIPプロキシ** → **UA2 (Public IP)** のような基本的な通信パスを模擬します。
  * `INVITE`, `1xx`応答, `200 OK`, `ACK`, `BYE`といった主要なSIPメッセージフローを扱います。

## 環境構築と実行方法

### 必要なもの

  * Python 3.x

### セットアップ

1.  このリポジトリをクローンするか、`simple_sip_proxy.py` ファイルをダウンロードします。

### 実行方法

1.  ターミナルまたはコマンドプロンプトを開きます。

2.  スクリプトがあるディレクトリに移動します。

3.  以下のコマンドを実行してプロキシを起動します。

    ```bash
    python simple_sip_proxy.py
    ```

    プロキシが起動すると、以下のようなメッセージが表示されます。

    ```
    SIPプロキシが 127.0.0.1:5060 でリッスン中...
    ```

### 設定

プログラム内の `SIP_PROXY_IP`, `SIP_PROXY_PORT`, `UA_MAPPING` 変数を変更することで、プロキシの動作や模擬するUAのネットワーク設定を調整できます。

```python
# --- SIPプロキシの設定 ---
SIP_PROXY_IP = '127.0.0.1'  # プロキシがリッスンするIPアドレス (通常は外部からアクセス可能なIP)
SIP_PROXY_PORT = 5060       # プロキシがリッスンするポート

# 簡易的なUA情報（本来はレジストラから取得）
# この例では、UA2はPublic IPを持つと仮定
UA_MAPPING = {
    'alice': {'ip': '192.168.1.100', 'port': 5060, 'nat_ip': '203.0.113.1', 'nat_port': 50000}, # NAT内UA
    'bob': {'ip': '200.200.200.200', 'port': 5060, 'nat_ip': None, 'nat_port': None} # Public IP UA
}
```

  * `alice`: NATの内側にいるUAを模擬します。`nat_ip`と`nat_port`は、NATルータによって割り当てられるグローバルIPとポートを模倣する値です。
  * `bob`: パブリックIPを持つUAを模擬します。

## テスト方法（概念的）

このプロキシを実際にテストするには、SIPクライアントが必要です。

1.  **このSIPプロキシを起動します。**
2.  **SIPクライアントA (UA1を模擬)**:
      * SIPクライアントAの設定で、自身のユーザー名を `alice` とします。
      * **アウトバウンドプロキシ**として、このPythonプロキシのIPアドレスとポート (`127.0.0.1:5060` または設定したIP/ポート) を設定します。
      * クライアントAが NATの内側にあることを模擬するため、クライアントAのローカルIPアドレス（またはこのプロキシが`UA_MAPPING['alice']['ip']`として認識するIP）からの通信を想定してください。
      * `bob` (`bob@200.200.200.200` または `UA_MAPPING['bob']['ip']` に設定したIP) へ発信を試みます。
3.  **SIPクライアントB (UA2を模擬)**:
      * SIPクライアントBのユーザー名を `bob` とします。
      * SIPプロキシ (`127.0.0.1:5060` または設定したIP/ポート) をレジストラ/プロキシとして設定し、`bob`として登録します。
      * クライアントBがパブリックIPにあることを模擬するため、クライアントBのローカルIPアドレス（またはこのプロキシが`UA_MAPPING['bob']['ip']`として認識するIP）からの通信を想定してください。

### 期待される動作

  * UA1からの`INVITE`はプロキシによってSIPヘッダが更新され（Viaの追加、Record-Routeの挿入、Contactの書き換えなど）、UA2へ転送されます。
  * UA2からの`200 OK`はプロキシによってViaヘッダが処理され、UA1へ転送されます。
  * `ACK`や`BYE`などの後続のメッセージは、`Record-Route`（ダイアログ確立後に`Route`ヘッダとして利用される）に従い、必ずプロキシを経由してルーティングされます。

-----

## 制限事項

  * **学習目的のみ**: 実際の運用には不向きです。
  * **UDPのみ**: TCPやTLSといった他のSIPトランスポートはサポートしていません。
  * **簡易的なパース**: SIPメッセージのパースは非常に基本的なものであり、複雑なSIPメッセージやエラーケースには対応していません。
  * **状態管理なし**: トランザクションやダイアログの完全な状態管理は行いません。
  * **認証・登録なし**: ユーザー認証やレジストラ機能は実装していません。
  * **メディア（RTP）転送なし**: SIPシグナリングのみを扱い、音声/ビデオなどのメディアストリームの転送やNAT越え処理は行いません。メディアのNAT越えには、STUN/TURN/ICEやSBCなどの別途メカニズムが必要です。

## ライセンス

このプロジェクトは、特にライセンスを定めていません。学習目的での自由な利用、改変、配布を推奨します。

-----